<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Statistics</title>
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/home.css" rel="stylesheet">
    <link rel="stylesheet" href="fontawesome-free-6.5.1-web/css/all.min.css">
     <style>
    #chartContainer {
        max-height: 500px;
        width: 80%; /* Ajusta al ancho que prefieras */
        margin: 20px auto; /* Aumenta el margen superior para más espacio */
        background-color: #f0f0f0;
        padding: 20px;
        border-radius: 8px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        align-items: center; /* Centrar los elementos horizontalmente */
        gap: 20px; /* Espacio entre los gráficos */
    }

    canvas {
        width: 80%; /* Ocupar todo el ancho del contenedor de gráficos */
        height: 200px; /* Altura auto ajustable */
        margin: 0 auto; /* Centrar el gráfico horizontalmente dentro del contenedor */
    }

    #myChart {
        width: 80%; 
        height: 200px; /* Altura predefinida para el gráfico doughnut */
        margin: 0 auto; /* Centrar el gráfico horizontalmente dentro del contenedor */
    }

    #chartContainer h3 {
        color: #333;
        text-align: center; /* Centrar el texto del título */
    }

    #averageTableContainer {
        padding: 20px;
        margin-top: 20px;
        background-color: #433e3e; /* Un fondo claro pero ligeramente diferenciado */
        border: 1px solid #4d4848; /* Borde sutil */
        border-radius: 8px; /* Esquinas redondeadas */
        box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Sombra ligera para profundidad */
        width: 100%; /* Utiliza todo el ancho disponible del contenedor padre */
        overflow-x: auto; /* Permite desplazamiento horizontal si es necesario */
    }

    table {
        width: 100%;
        margin-top: 0; /* No es necesario ya que el contenedor ya gestiona el espaciamiento */
        border-collapse: collapse; /* Para que los bordes de las celdas se unan */
        background-color: #433e3e; /* Fondo blanco para la tabla para maximizar el contraste */
    }

    table, th, td {
        border: 1px solid #9f9c9c; /* Bordes claros para las celdas y la tabla */
    }

    th, td {
        text-align: left;
        padding: 12px; /* Padding generoso para facilidad de lectura */
        color: #fdfdfd; /* Texto oscuro para contraste con fondo claro */
    }

    th {
        background-color: #433e3e; /* Fondo oscuro para los encabezados para destacarlos */
        color: #fff; /* Texto blanco en encabezados para contraste */
    }

    tr:nth-child(even) {
        background-color: #433e3e; /* Alternar colores para filas pares para mejorar la legibilidad */
    }

    tr:hover {
        background-color: #ddd; /* Efecto hover para interactividad, resalta la fila sobre la que está el cursor */
    }
    </style>
</head>

<body>
    <div id="navbarContainer"></div>
    <header>
        <div class="header-content">
            <div class="header-content-inner" id="chartContainer">
                <div id="averageTableContainer"></div>
                <canvas id="myChart"></canvas>
            </div>
            <button type="button" class="btn btn-primary btn-lg back" onclick="goBack()">Return</button>
        </div>
    </header>

    <script src="js/jquery-1.11.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <!-- Cargar Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <!-- Cargar el plugin de boxplot, asegurándote de que la versión es compatible -->
    <script src="https://cdn.jsdelivr.net/npm/@sgratzl/chartjs-chart-boxplot"></script>
        
    <script>
        $(document).ready(function () {
            $('#navbarContainer').load('navbar.html');
            const urlParams = new URLSearchParams(window.location.search);
            const chatbotId = urlParams.get('chatbotId');
            const questionnaireId = urlParams.get('questionnaireId');

            loadResults(chatbotId, questionnaireId);
        });

        function goBack() {
            window.history.back();
        }

        function displayAverageTable(numberQuestions) {
            var table = '<table class="table table-striped"><thead><tr><th>Question</th><th>Average Answer</th></tr></thead><tbody>';
            
            numberQuestions.forEach(function(item) {
                table += `<tr><td>${item.question.question}</td><td>${item.average.toFixed(2)}</td></tr>`; 
            });

            table += '</tbody></table>';

            $('#averageTableContainer').html(table);
        }


        function loadResults(chatbotId, questionnaireId) {
            $.get(`https://backend-chatbotevaluator.up.railway.app/results?chatbotId=${chatbotId}&questionnaireId=${questionnaireId}`, function (results) {
                console.log(results);
                const susValues = results.filter(result => result.sus !== -1);
                if (susValues.length > 0) {
                    var userId = localStorage.getItem('userId');
                    $.get(`https://backend-chatbotevaluator.up.railway.app/users/${userId}/questionnaires/${questionnaireId}`, function (questionnaire) {
                        console.log(questionnaire);
                        if (questionnaire && questionnaire.questions) {
                            console.log(questionnaire.questions);
                            let transformedQuestions = {};
                            let index = 0;

                            questionnaire.questions.forEach(question => {
                                transformedQuestions[index++] = question.positive;
                                transformedQuestions[index++] = question.negative;
                            });

                            console.log(transformedQuestions);
                            createChart(susValues.map(result => result.sus));
                            generateBoxPlots(susValues, transformedQuestions);
                        }
                    });
                } else {
                    var userId = localStorage.getItem('userId');
                    const values = results.filter(result => result.sus === -1);
                    $.get(`https://backend-chatbotevaluator.up.railway.app/users/${userId}/questionnaires/${questionnaireId}`, function (questionnaire) {
                        console.log(questionnaire);
                        if (questionnaire && questionnaire.questions) {
                            console.log(questionnaire.questions);
                            const listQuestions = [];
                            const yesNoQuestions = [];
                            const numberQuestions = [];
                            var index = 0;
                            questionnaire.questions.forEach(function (question, index) {
                                index += 1;
                                if (question.type.toLowerCase() === 'list') {
                                    console.log(index);
                                    console.log(question);
                                    listQuestions.push({ question, index });
                                } else if (question.type.toLowerCase() === 'yesno') {
                                    console.log(index);
                                    console.log(question);
                                    yesNoQuestions.push({ question, index });
                                } else if (question.type.toLowerCase() === 'number' || question.type.toLowerCase() === 'scale') {
                                    console.log(index);
                                    console.log(question);
                             
                                    const responses = results.map(result => Number(result.answers[index] || 0));
                                    const average = responses.reduce((sum, current) => sum + current, 0) / responses.length;
                                    console.log(`Average for question ${index}: ${average}`);
                                    numberQuestions.push({ question, index, average });
                                }
                            });

                            if (listQuestions.length > 0) {
                                listQuestions.forEach(function (item) {
                                    const question = item.question;
                                    const index = item.index;
                                    console.log(question);
                                    console.log(results);
                                    generateListGraph(question, results, index); // Pasar el índice como tercer parámetro
                                });
                            }
                            if (yesNoQuestions.length > 0) {
                                yesNoQuestions.forEach(function (item) {
                                    const question = item.question;
                                    const index = item.index;
                                    console.log(question);
                                    console.log(results);
                                    generateYesNoGraph(question, results, index); // Pasar el índice como tercer parámetro
                                });
                            }

                            if (numberQuestions.length > 0) {
                                displayAverageTable(numberQuestions);
                            }

                        }
                    });
                }

            });
        }

        function generateListGraph(question, results, index) {
            // Conteo de respuestas para cada opción de la lista
            const optionCounts = {};
            question.answerOptions.forEach(function (option) {
                optionCounts[option] = 0;
            });

            // Contar respuestas en los resultados
            results.forEach(function (result) {
                console.log(result.answers[index]);
                if (optionCounts.hasOwnProperty(result.answers[index])) {
                    optionCounts[result.answers[index]]++;
                    console.log(optionCounts[result.answers[index]]);
                }
            });

            // Preparar datos para la gráfica
            const labels = Object.keys(optionCounts);
            const data = labels.map(option => optionCounts[option]);

            // Crear el canvas para la gráfica
            const chartCanvas = $('<canvas>').addClass('list-chart');
            $('#chartContainer').append($('<h3>').text(question.question)).append(chartCanvas);
            // Generar la gráfica
            const ctx = chartCanvas[0].getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Response Count',
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Response Count'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Options'
                            }
                        }
                    }
                }
            });
        }

        function generateYesNoGraph(question, results, index) {
            const yesCount = results.filter(result => result.answers[index] === 'Yes').length;
            const noCount = results.filter(result => result.answers[index] === 'No').length;

            // Crear un nuevo elemento canvas para el gráfico yesno
            const chartCanvas = $('<canvas>').addClass('doughnut-chart');
            $('#chartContainer').append($('<h3>').text(question.question)).append(chartCanvas);

            // Obtener el contexto del canvas
            const ctx = chartCanvas[0].getContext('2d');

            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Yes', 'No'],
                    datasets: [{
                        label: 'Yes/No',
                        data: [yesCount, noCount],
                        backgroundColor: [
                            'rgba(54, 162, 235, 0.5)',
                            'rgba(255, 99, 132, 0.5)',
                        ],
                        borderColor: [
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 99, 132, 1)',
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true, // Hace que el gráfico se ajuste al contenedor
                    maintainAspectRatio: false, // Evita que el gráfico se estire para mantener la relación de aspecto
                }
            });
        }

        function createChart(susValues) {
            const ctx = document.getElementById('myChart').getContext('2d');
            const myChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Array.from({length: susValues.length}, (_, i) => `Q ${i+1}`),
                    datasets: [{
                        label: '# Participants',
                        data: susValues,
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Importante para mantener la relación de aspecto
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'SUS Score'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Questionnaires'
                            }
                        }
                    }
                }
            });
        }


        function generateBoxPlots(results, questions) {
            const questionResponses = {};
            results.forEach(result => {
                Object.entries(result.answers).forEach(([question, response]) => {
                    if (!questionResponses[question]) {
                        questionResponses[question] = [];
                    }
                    questionResponses[question].push(Number(response)); // Asegurándonos de que las respuestas son números
                });
            });

            console.log(questionResponses);

            Object.entries(questionResponses).forEach(([question, responses], index) => {
                const canvasId = 'boxPlot' + question;
                const canvasElement = `<canvas id="${canvasId}"></canvas>`;
                $('#chartContainer').append(canvasElement);
                const ctx = document.getElementById(canvasId).getContext('2d');
                new Chart(ctx, {
                    type: 'boxplot',
                    data: {
                        labels: [questions[index]],
                        datasets: [{
                            label: 'Answers for Question ' + question,
                            data: [responses],
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)'
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            });
        }

        
    </script>

</body>

</html>
