<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Statistics</title>
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/home.css" rel="stylesheet">
    <link rel="stylesheet" href="fontawesome-free-6.5.1-web/css/all.min.css">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <style>
        #chartContainer {
            width: 80%;
            margin: 0 auto;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            overflow: auto;
            max-height: 400px;
            position: relative; /* Hacer que el contenedor sea relativo para posicionar el botón de flecha */
        }

        .chart-content {
            width: 100%;
            display: flex;
            transition: transform 0.3s ease; /* Animación para suavizar el cambio */
        }

        .chart-content canvas {
            width: 100%;
            max-width: 100%;
            height: auto; /* Hacer que los gráficos sean responsivos */
        }

        #nextChartButton {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 24px;
            color: #007bff;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="navbarContainer"></div>
    <header>
        <div class="header-content">
            <div id="chartContainer">
                <div class="chart-content">
                    <!-- Aquí se mostrarán los gráficos -->
                </div>
                <button id="nextChartButton" onclick="showNextChart()">
                    <i class="fas fa-arrow-right"></i>
                </button>
            </div>
            <button type="button" class="btn btn-primary btn-lg back" onclick="goBack()">Return</button>
        </div>
    </header>

    <script src="js/jquery-1.11.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script>
        $(document).ready(function () {
            $('#navbarContainer').load('navbar.html');
            const urlParams = new URLSearchParams(window.location.search);
            const chatbotId = urlParams.get('chatbotId');
            const questionnaireId = urlParams.get('questionnaireId');

            loadResults(chatbotId, questionnaireId);
        });

        function goBack() {
            window.history.back();
        }

        function loadResults(chatbotId, questionnaireId) {
            $.get(`https://backend-chatbotevaluator.up.railway.app/results?chatbotId=${chatbotId}&questionnaireId=${questionnaireId}`, function (results) {
                console.log(results);
                const susValues = results
                    .filter(result => result.sus !== -1)
                    .map(result => result.sus);

                if (susValues.length > 0) {
                    createChart(susValues);
                } else {
                    var userId = localStorage.getItem('userId');
                    $.get(`https://backend-chatbotevaluator.up.railway.app/users/${userId}/questionnaires/${questionnaireId}`, function (questionnaire) {
                        console.log(questionnaire);
                        if (questionnaire && questionnaire.questions) {
                            console.log(questionnaire.questions);
                            const listQuestions = [];
                            const yesNoQuestions = [];
                            var index = 0;
                            questionnaire.questions.forEach(function (question, index) {
                                index += 1;
                                if (question.type.toLowerCase() === 'list') {
                                    console.log(index);
                                    console.log(question);
                                    listQuestions.push({ question, index });
                                } else if (question.type.toLowerCase() === 'yesno') {
                                    console.log(index);
                                    console.log(question);
                                    yesNoQuestions.push({ question, index });
                                }
                            });

                            if (listQuestions.length > 0) {
                                listQuestions.forEach(function (item) {
                                    const question = item.question;
                                    const index = item.index;
                                    console.log(question);
                                    console.log(results);
                                    generateListGraph(question, results, index); // Pasar el índice como tercer parámetro
                                });
                            }
                            if (yesNoQuestions.length > 0) {
                                yesNoQuestions.forEach(function (item) {
                                    const question = item.question;
                                    const index = item.index;
                                    console.log(question);
                                    console.log(results);
                                    generateYesNoGraph(question, results, index); // Pasar el índice como tercer parámetro
                                });
                            }
                        }
                    });
                }

            });
        }

        let currentChartIndex = 0;
        let charts = [];

        function generateListGraph(question, results, index) {
            // Conteo de respuestas para cada opción de la lista
            const optionCounts = {};
            question.answerOptions.forEach(function (option) {
                optionCounts[option] = 0;
            });

            // Contar respuestas en los resultados
            results.forEach(function (result) {
                console.log(result.answers[index]);
                if (optionCounts.hasOwnProperty(result.answers[index])) {
                    optionCounts[result.answers[index]]++;
                    console.log(optionCounts[result.answers[index]]);
                }
            });

            // Preparar datos para la gráfica
            const labels = Object.keys(optionCounts);
            const data = labels.map(option => optionCounts[option]);

            // Crear el canvas para la gráfica
            const chartCanvas = $('<canvas>').addClass('list-chart');
            $('.chart-content').append($('<div>').append($('<h3>').text(question.question)).append(chartCanvas));
            // Generar la gráfica
            const ctx = chartCanvas[0].getContext('2d');
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Response Count',
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Response Count'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Options'
                            }
                        }
                    }
                }
            });
            charts.push(chart);
        }

        function generateYesNoGraph(question, results, index) {
            const yesCount = results.filter(result => result.answers[index] === 'Yes').length;
            const noCount = results.filter(result => result.answers[index] === 'No').length;

            // Crear un nuevo elemento canvas para el gráfico yesno
            const chartCanvas = $('<canvas>').addClass('doughnut-chart');
            $('.chart-content').append($('<div>').append($('<h3>').text(question.question)).append(chartCanvas));

            // Obtener el contexto del canvas
            const ctx = chartCanvas[0].getContext('2d');

            const chart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Yes', 'No'],
                    datasets: [{
                        label: 'Yes/No',
                        data: [yesCount, noCount],
                        backgroundColor: [
                            'rgba(54, 162, 235, 0.5)',
                            'rgba(255, 99, 132, 0.5)',
                        ],
                        borderColor: [
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 99, 132, 1)',
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true, // Hace que el gráfico se ajuste al contenedor
                    maintainAspectRatio: false, // Evita que el gráfico se estire para mantener la relación de aspecto
                }
            });
            charts.push(chart);
        }

        function createChart(susValues) {
            const roundedSusValues = susValues.map(value => Math.round(value));

            // Encontrar el valor máximo de SUS redondeado en los datos
            const maxSus = Math.max(...roundedSusValues);

            // Crear un arreglo con todos los valores de SUS posibles, desde 0 hasta el máximo encontrado
            const allSusValues = Array.from({ length: maxSus + 1 }, (_, i) => i);

            // Conteo de la frecuencia de cada valor SUS redondeado
            const susCounts = {};
            allSusValues.forEach(sus => {
                susCounts[sus] = roundedSusValues.filter(value => value === sus).length;
            });

            const labels = Object.keys(susCounts);
            const data = labels.map(sus => susCounts[sus]);

            const ctx = document.getElementById('myChart').getContext('2d');
            const myChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Participants',
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Participants'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'SUS Score'
                            },
                            type: 'category',
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
            charts.push(myChart);
        }

        function showNextChart() {
            currentChartIndex = (currentChartIndex + 1) % charts.length;
            const offsetX = -currentChartIndex * 100;
            $('.chart-content').css('transform', `translateX(${offsetX}%)`);
        }
    </script>

</body>

</html>
